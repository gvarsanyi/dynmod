// Generated by CoffeeScript 1.7.1
(function() {
  var cache, child_process, dir, fs, home_folder_ref, list_all, most_vurrent_installed_versions, read,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  child_process = require('child_process');

  fs = require('fs');

  home_folder_ref = process.platform === 'win32' ? 'USERPROFILE' : 'HOME';

  dir = process.env[home_folder_ref] + '/.dynmod';

  cache = {};

  most_vurrent_installed_versions = {};

  read = function(pkg, version, callback) {
    var err, mod, path;
    try {
      path = dir + '/' + pkg + '/' + version + '/node_modules/' + pkg;
      mod = require(path);
      (cache[pkg] != null ? cache[pkg] : cache[pkg] = {})[version] = mod;
      return callback(null, mod);
    } catch (_error) {
      err = _error;
      return callback(err);
    }
  };

  module.exports.require = module.exports = function(pkg, version, callback) {
    var mod, verify_version, _ref;
    if (typeof version === 'function') {
      callback = version;
      version = false;
    }
    if (mod = ((_ref = cache[pkg]) != null ? _ref[version || most_vurrent_installed_versions[pkg]] : void 0) != null) {
      return callback(null, mod);
    }
    verify_version = function() {
      return fs.exists(dir + '/' + pkg + '/' + version + '/.dynmod-proper', function(exists) {
        var msg;
        if (exists) {
          return read(pkg, version, callback);
        }
        msg = pkg + '@' + version + ' is partially installed (possibly being ' + 'installed by an other process?). If you are sure this is a ' + 'failed installation, use require(\'dynmod\').remove(\'' + pkg + '\', \'' + version + '\'); to remove it.';
        return callback(new Error(msg));
      });
    };
    if (!version) {
      return module.exports.list(pkg, function(err, versions) {
        if (err) {
          return callback(err);
        }
        if (versions && versions.length > 0) {
          version = versions.pop();
          return verify_version();
        } else {
          return module.exports.install(pkg, function(err, version) {
            if (err) {
              return callback(err);
            }
            version = versions.pop();
            return verify_version();
          });
        }
      });
    } else {
      return verify_version();
    }
  };

  module.exports.remove = function(pkg, version, callback) {
    var pkg_dir;
    if (!version) {
      return callback(new Error('version is required to remove'));
    }
    console.log('[dynmod] removing ' + pkg + '@' + version);
    if (cache[pkg] != null) {
      delete cache[pkg][version];
    }
    pkg_dir = dir + '/' + pkg;
    return child_process.exec('rm -rf ' + pkg_dir + '/' + version, function(err) {
      if (err) {
        return callback(err);
      }
      return fs.readdir(pkg_dir, function(err, files) {
        if (err || (files && files.length)) {
          return callback();
        }
        return child_process.exec('rm -rf ' + pkg_dir, function(err) {
          return callback();
        });
      });
    });
  };

  module.exports.install = function(pkg, version, callback) {
    var install;
    install = function() {
      return module.exports.list(pkg, function(err, versions) {
        var pkg_dir;
        if (err) {
          return callback(err);
        }
        if (versions && versions.length && __indexOf.call(versions, version) >= 0) {
          return callback(new Error(pkg + '@' + version + ' is already installed'));
        }
        pkg_dir = dir + '/' + pkg + '/' + version;
        return child_process.exec('mkdir -p ' + pkg_dir, function(err) {
          var cm;
          if (err) {
            return callback(err);
          }
          console.log('[dynmod] attempting to install ' + pkg + '@' + version);
          cm = 'npm install ' + pkg + '@' + version + ' 2>1 | grep -v "npm http "';
          return child_process.exec(cm, {
            cwd: pkg_dir
          }, function(err, stdout) {
            var path;
            if (err) {
              return module.exports.remove(pkg, version, function() {
                return callback(err);
              });
            }
            path = dir + '/' + pkg + '/' + version + '/.dynmod-proper';
            return fs.writeFile(path, '1', function(err) {
              if (err) {
                return callback(err);
              }
              delete most_vurrent_installed_versions[pkg];
              console.log('[dynmod] installed ' + pkg + '@' + version);
              return callback(null, version);
            });
          });
        });
      });
    };
    if (typeof version === 'function') {
      callback = version;
      version = false;
    }
    if (version) {
      return install();
    }
    return module.exports.current(pkg, function(err, latest_version) {
      if (err) {
        return callback(err);
      }
      version = latest_version;
      return install();
    });
  };

  list_all = function(callback) {
    var count, dict, errors, total;
    errors = [];
    count = 0;
    total = null;
    dict = {};
    return fs.readdir(dir, function(err, pkgs) {
      var pkg, _i, _j, _len, _len1, _results;
      if (err || !pkgs.length) {
        return callback(err, {});
      }
      total = pkgs.length;
      for (_i = 0, _len = pkgs.length; _i < _len; _i++) {
        pkg = pkgs[_i];
        dict[pkg] = null;
      }
      _results = [];
      for (_j = 0, _len1 = pkgs.length; _j < _len1; _j++) {
        pkg = pkgs[_j];
        _results.push((function(pkg) {
          return module.exports.list(pkg, function(err, versions) {
            if (err) {
              errors.push(err);
              delete dict[pkg];
            } else if (!(versions && versions.length)) {
              delete dict[pkg];
            } else {
              dict[pkg] = versions;
            }
            count += 1;
            if (count === total) {
              if (errors.length) {
                return callback(errors);
              }
              return callback(null, dict);
            }
          });
        })(pkg));
      }
      return _results;
    });
  };

  module.exports.list = function(pkg, callback) {
    if (typeof pkg === 'function') {
      return list_all(pkg);
    }
    if (!pkg) {
      return list_all(callback);
    }
    return fs.exists(dir + '/' + pkg, function(exists) {
      if (!exists) {
        return callback(null, false);
      }
      return fs.readdir(dir + '/' + pkg, function(err, versions) {
        delete most_vurrent_installed_versions[pkg];
        if (!versions.length) {
          return callback(null, false);
        }
        if (versions && versions.length) {
          most_vurrent_installed_versions[pkg] = versions[versions.length - 1];
        }
        return callback(null, versions);
      });
    });
  };

  module.exports.current = function(pkg, callback) {
    var cmd;
    cmd = 'npm show ' + pkg + ' version 2> /dev/null';
    return child_process.exec(cmd, function(err, stdout, stderr) {
      var current;
      if (err) {
        return callback(err);
      }
      current = stdout.replace(/^\s+|\s+$/g, '');
      return module.exports.list(pkg, function(err, versions) {
        return callback(null, current, versions && __indexOf.call(versions, current) >= 0, versions);
      });
    });
  };

}).call(this);
