// Generated by CoffeeScript 1.7.1
(function() {
  var async, child_process, exec_sync, list, sync,
    __slice = [].slice;

  child_process = require('child_process');

  exec_sync = require('sync-exec');

  list = require('./list');

  async = function(pkgs, callback) {
    var count, errors, modules, pkg, read_pkg, total, _i, _len, _results;
    if (!pkgs.length) {
      return callback(new Error('A module name is required'));
    }
    errors = [];
    modules = {};
    count = 0;
    total = pkgs.length;
    read_pkg = function(pkg) {
      var cmd, conclude;
      modules[pkg] = null;
      conclude = function(err, mod) {
        var response;
        count += 1;
        if (err) {
          errors.push(err);
        }
        modules[pkg] = mod;
        if (count >= total) {
          response = [];
          for (pkg in modules) {
            mod = modules[pkg];
            response.push(mod);
          }
          if (errors.length === 1) {
            return callback.apply(null, [errors[0]].concat(__slice.call(response)));
          } else if (errors.length > 1) {
            return callback.apply(null, [errors].concat(__slice.call(response)));
          } else {
            return callback.apply(null, [null].concat(__slice.call(response)));
          }
        }
      };
      if (pkg.indexOf('@') > -1) {
        return conclude(new Error('Version is not required'));
      }
      cmd = 'npm show ' + pkg + ' version 2> /dev/null';
      return child_process.exec(cmd, function(err, stdout, stderr) {
        var current;
        if (err) {
          return conclude(err);
        }
        current = stdout.replace(/^\s+|\s+$/g, '');
        return conclude(null, current);
      });
    };
    _results = [];
    for (_i = 0, _len = pkgs.length; _i < _len; _i++) {
      pkg = pkgs[_i];
      _results.push(read_pkg(pkg));
    }
    return _results;
  };

  sync = function(pkgs) {
    var current, modules, pkg, status, stderr, stdout, _i, _len, _ref;
    if (!pkgs.length) {
      throw new Error('A module name is required');
    }
    modules = [];
    for (_i = 0, _len = pkgs.length; _i < _len; _i++) {
      pkg = pkgs[_i];
      if (pkg.indexOf('@') > -1) {
        throw new Error('Version is not required');
      }
      _ref = exec_sync('npm show ' + pkg + ' version'), status = _ref.status, stdout = _ref.stdout, stderr = _ref.stderr;
      if (status) {
        throw new Error(stderr);
      }
      current = stdout.replace(/^\s+|\s+$/g, '');
      modules.push(current);
    }
    if (pkgs.length === 1) {
      return modules[0];
    }
    return modules;
  };

  module.exports = function() {
    var args, callback;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0 || typeof args[args.length - 1] !== 'function') {
      return sync(args);
    }
    callback = args.pop();
    async(args, callback);
    return null;
  };

}).call(this);
