// Generated by CoffeeScript 1.7.1
(function() {
  var async, cache, child_process, current, dir, exec_sync, fs, list, remove, sync,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  child_process = require('child_process');

  exec_sync = require('sync-exec');

  fs = require('fs');

  cache = require('../cache');

  current = require('./current');

  dir = require('../dir');

  list = require('./list');

  remove = require('./remove');

  async = function(specs, callback) {
    var count, errors, modules, read_spec, spec, total, _i, _len, _results;
    if (!specs.length) {
      return callback(new Error('A module name is required'));
    }
    errors = [];
    modules = {};
    count = 0;
    total = specs.length;
    read_spec = function(spec) {
      var conclude, install, pkg, version, _ref;
      modules[spec] = null;
      conclude = function(err, mod) {
        var response;
        count += 1;
        if (err) {
          errors.push(err);
        }
        modules[spec] = mod;
        if (count >= total) {
          response = [];
          for (spec in modules) {
            mod = modules[spec];
            response.push(mod);
          }
          if (errors.length === 1) {
            return callback.apply(null, [errors[0]].concat(__slice.call(response)));
          } else if (errors.length > 1) {
            return callback.apply(null, [errors].concat(__slice.call(response)));
          } else {
            return callback.apply(null, [null].concat(__slice.call(response)));
          }
        }
      };
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      install = function() {
        return list(pkg, function(err, versions) {
          var msg, pkg_dir;
          if (versions && versions.length && __indexOf.call(versions, version) >= 0) {
            msg = pkg + '@' + version + ' is already installed';
            return conclude(new Error(msg), version);
          }
          pkg_dir = dir + '/' + pkg + '/' + version;
          return child_process.exec('mkdir -p ' + pkg_dir, function(err) {
            var cmd;
            if (err) {
              return conclude(err);
            }
            console.log('[dynmod] attempting to install ' + pkg + '@' + version);
            cmd = 'npm install ' + pkg + '@' + version + ' 2>1 | grep -v ' + '"npm http "';
            return child_process.exec(cmd, {
              cwd: pkg_dir
            }, function(err, stdout) {
              var path;
              if (err) {
                console.log('[dynmod] failed to install ' + pkg + '@' + version + ' -- cleaning up');
                return remove(spec, function() {
                  return conclude(err);
                });
              }
              path = dir + '/' + pkg + '/' + version + '/.dynmod-proper';
              return fs.writeFile(path, '1', function(err) {
                if (err) {
                  return conclude(err);
                }
                delete cache.current[pkg];
                console.log('[dynmod] installed ' + pkg + '@' + version);
                return conclude(null, version);
              });
            });
          });
        });
      };
      if (version) {
        return install();
      }
      return current(pkg, function(err, latest_version) {
        if (err) {
          return callback(err);
        }
        version = latest_version;
        return install();
      });
    };
    _results = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _results.push(read_spec(spec));
    }
    return _results;
  };

  sync = function(specs) {
    var cmd, err, modules, path, pkg, pkg_dir, spec, status, stderr, stdout, version, versions, _i, _len, _ref, _ref1, _ref2;
    if (!specs.length) {
      throw new Error('A module name is required');
    }
    modules = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      if (!version) {
        version = current(pkg);
      }
      versions = list(pkg);
      if (versions && versions.length && __indexOf.call(versions, version) >= 0) {
        throw new Error(pkg + '@' + version + ' is already installed');
      }
      pkg_dir = dir + '/' + pkg + '/' + version;
      console.log('[dynmod] attempting to install ' + pkg + '@' + version);
      _ref1 = exec_sync('mkdir -p ' + pkg_dir), status = _ref1.status, stdout = _ref1.stdout, stderr = _ref1.stderr;
      if (status) {
        throw new Error(stderr);
      }
      cmd = 'npm install ' + pkg + '@' + version + ' 2>1 | grep -v "npm http "';
      _ref2 = exec_sync(cmd, {
        cwd: pkg_dir
      }), status = _ref2.status, stdout = _ref2.stdout, stderr = _ref2.stderr;
      try {
        if (status) {
          throw new Error(stderr);
        }
        path = dir + '/' + pkg + '/' + version + '/.dynmod-proper';
        fs.writeFileSync(path, '1');
      } catch (_error) {
        err = _error;
        console.log('[dynmod] failed to install ' + pkg + '@' + version + ' -- cleaning up');
        remove(spec);
        throw new Error(err);
      }
      delete cache.current[pkg];
      console.log('[dynmod] installed ' + pkg + '@' + version);
      modules.push(version);
    }
    if (specs.length === 1) {
      return modules[0];
    }
    return modules;
  };

  module.exports = function() {
    var args, callback;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0 || typeof args[args.length - 1] !== 'function') {
      return sync(args);
    }
    callback = args.pop();
    async(args, callback);
    return null;
  };

}).call(this);
