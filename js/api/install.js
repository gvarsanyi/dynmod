// Generated by CoffeeScript 1.7.1
(function() {
  var cache, child_process, current, dir, exec_sync, fs, list, remove,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  child_process = require('child_process');

  exec_sync = require('sync-exec');

  fs = require('fs');

  cache = require('../cache');

  current = require('./current');

  dir = require('../dir');

  list = require('./list');

  remove = require('./remove');

  module.exports = function(spec, callback) {
    var install, pkg, version, _ref;
    _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
    install = function() {
      return list(pkg, function(err, versions) {
        var pkg_dir;
        if (err) {
          return callback(err);
        }
        if (versions && versions.length && __indexOf.call(versions, version) >= 0) {
          return callback(new Error(pkg + '@' + version + ' is already installed'));
        }
        pkg_dir = dir + '/' + pkg + '/' + version;
        return child_process.exec('mkdir -p ' + pkg_dir, function(err) {
          var cm;
          if (err) {
            return callback(err);
          }
          console.log('[dynmod] attempting to install ' + pkg + '@' + version);
          cm = 'npm install ' + pkg + '@' + version + ' 2>1 | grep -v "npm http "';
          return child_process.exec(cm, {
            cwd: pkg_dir
          }, function(err, stdout) {
            var path;
            if (err) {
              console.log('[dynmod] failed to install ' + pkg + '@' + version + ' -- cleaning up');
              return remove(spec, function() {
                return callback(err);
              });
            }
            path = dir + '/' + pkg + '/' + version + '/.dynmod-proper';
            return fs.writeFile(path, '1', function(err) {
              if (err) {
                return callback(err);
              }
              delete cache.current[pkg];
              console.log('[dynmod] installed ' + pkg + '@' + version);
              return callback(null, version);
            });
          });
        });
      });
    };
    if (version) {
      return install();
    }
    return current(pkg, function(err, latest_version) {
      if (err) {
        return callback(err);
      }
      version = latest_version;
      return install();
    });
  };

  module.exports.sync = function(spec) {
    var cmd, err, path, pkg, pkg_dir, status, stderr, stdout, version, versions, _ref, _ref1, _ref2;
    _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
    if (!version) {
      version = current.sync(pkg)[0];
    }
    versions = list.sync(pkg);
    if (versions && versions.length && __indexOf.call(versions, version) >= 0) {
      throw new Error(pkg + '@' + version + ' is already installed');
    }
    pkg_dir = dir + '/' + pkg + '/' + version;
    console.log('[dynmod] attempting to install ' + pkg + '@' + version);
    _ref1 = exec_sync('mkdir -p ' + pkg_dir), status = _ref1.status, stdout = _ref1.stdout, stderr = _ref1.stderr;
    if (status) {
      throw new Error(stderr);
    }
    cmd = 'cd ' + pkg_dir + '; npm install ' + pkg + '@' + version + ' 2>1 ' + '| grep -v "npm http "';
    _ref2 = exec_sync(cmd), status = _ref2.status, stdout = _ref2.stdout, stderr = _ref2.stderr;
    try {
      if (status) {
        throw new Error(stderr);
      }
      path = dir + '/' + pkg + '/' + version + '/.dynmod-proper';
      fs.writeFileSync(path, '1');
    } catch (_error) {
      err = _error;
      console.log('[dynmod] failed to install ' + pkg + '@' + version + ' -- cleaning up');
      remove.sync(spec);
      throw new Error(err);
    }
    delete cache.current[pkg];
    console.log('[dynmod] installed ' + pkg + '@' + version);
    return version;
  };

}).call(this);
