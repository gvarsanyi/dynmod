// Generated by CoffeeScript 1.7.1
(function() {
  var async, dir, fs, install, list, sync,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  dir = require('../dir');

  list = require('./list');

  install = require('./install');

  async = function(specs, callback) {
    var count, errors, modules, read_spec, spec, total, _i, _len, _results;
    if (!specs.length) {
      return callback(new Error('A module name is required'));
    }
    errors = [];
    modules = {};
    count = 0;
    total = specs.length;
    read_spec = function(spec) {
      var conclude, get_bins, pkg, version, _ref;
      modules[spec] = null;
      conclude = function(err, mod) {
        var response;
        count += 1;
        if (err) {
          errors.push(err);
        }
        modules[spec] = mod;
        if (count >= total) {
          response = [];
          for (spec in modules) {
            mod = modules[spec];
            response.push(mod);
          }
          if (errors.length === 1) {
            return callback.apply(null, [errors[0]].concat(__slice.call(response)));
          } else if (errors.length > 1) {
            return callback.apply(null, [errors].concat(__slice.call(response)));
          } else {
            return callback.apply(null, [null].concat(__slice.call(response)));
          }
        }
      };
      get_bins = function() {
        var path;
        path = dir + '/' + pkg + '/' + version + '/node_modules/.bin';
        return fs.readdir(path, function(err, bins) {
          var bin, dict, _i, _len;
          if (err || !bins) {
            return conclude(null, []);
          }
          dict = {};
          for (_i = 0, _len = bins.length; _i < _len; _i++) {
            bin = bins[_i];
            dict[bin] = path + '/' + bin;
          }
          return conclude(null, dict);
        });
      };
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      return list(pkg, function(err, versions) {
        if (!version && versions && versions.length) {
          version = versions[versions.length - 1];
        }
        if (!(version && __indexOf.call(versions, version) >= 0)) {
          return install(spec, function(err, _version) {
            if (err) {
              return conclude(err);
            }
            version = _version;
            return get_bins();
          });
        } else {
          return get_bins();
        }
      });
    };
    _results = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _results.push(read_spec(spec));
    }
    return _results;
  };

  sync = function(specs) {
    var bin, bins, dict, modules, path, pkg, spec, version, versions, _i, _j, _len, _len1, _ref;
    if (!specs.length) {
      throw new Error('A module name is required');
    }
    modules = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      versions = list(pkg);
      if (!version && versions && versions.length) {
        version = versions[versions.length - 1];
      }
      if (!(version && __indexOf.call(versions, version) >= 0)) {
        install(spec);
      }
      path = dir + '/' + pkg + '/' + version + '/node_modules/.bin';
      bins = [];
      try {
        bins = fs.readdirSync(path);
      } catch (_error) {}
      dict = {};
      for (_j = 0, _len1 = bins.length; _j < _len1; _j++) {
        bin = bins[_j];
        dict[bin] = path + '/' + bin;
      }
      modules.push(dict);
    }
    if (specs.length === 1) {
      return modules[0];
    }
    return modules;
  };

  module.exports = function() {
    var args, callback;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0 || typeof args[args.length - 1] !== 'function') {
      return sync(args);
    }
    callback = args.pop();
    async(args, callback);
    return null;
  };

}).call(this);
