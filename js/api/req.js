// Generated by CoffeeScript 1.7.1
(function() {
  var async, cache, dir, err_msg, fs, install, list, sync, util,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  util = require('util');

  cache = require('../cache');

  dir = require('../dir');

  install = require('./install');

  list = require('./list');

  err_msg = '%s is partially installed (possibly being installed by an other pr' + 'ocess?). If you are sure this is a failed installation, use requir' + 'e(\'dynmod\').remove(\'%s\'); to remove it.';

  async = function(specs, callback) {
    var count, errors, modules, read_spec, spec, total, _i, _len, _results;
    if (!specs.length) {
      return callback(new Error('A module name is required'));
    }
    errors = [];
    modules = {};
    count = 0;
    total = specs.length;
    read_spec = function(spec) {
      var conclude, mod, pkg, read, verify_version, version, _ref, _ref1;
      modules[spec] = null;
      conclude = function(err, mod) {
        var response;
        count += 1;
        if (err) {
          errors.push(err);
        }
        modules[spec] = mod;
        if (count >= total) {
          response = [];
          for (spec in modules) {
            mod = modules[spec];
            response.push(mod);
          }
          if (errors.length === 1) {
            return callback.apply(null, [errors[0]].concat(__slice.call(response)));
          } else if (errors.length > 1) {
            return callback.apply(null, [errors].concat(__slice.call(response)));
          } else {
            return callback.apply(null, [null].concat(__slice.call(response)));
          }
        }
      };
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      if ((mod = (_ref1 = cache.pkg[pkg]) != null ? _ref1[version || cache.current[pkg]] : void 0) != null) {
        return conclude(null, mod);
      }
      read = function() {
        var err, path, _base;
        try {
          path = dir + '/' + pkg + '/' + version + '/node_modules/' + pkg;
          mod = require(path);
          ((_base = cache.pkg)[pkg] != null ? _base[pkg] : _base[pkg] = {})[version] = mod;
          return conclude(null, mod);
        } catch (_error) {
          err = _error;
          return conclude(err);
        }
      };
      verify_version = function() {
        return fs.exists(dir + '/' + pkg + '/' + version + '/.dynmod-proper', function(exists) {
          if (exists) {
            return read();
          }
          return conclude(new Error(util.format(err_msg, spec, spec)));
        });
      };
      return list(pkg, function(err, versions) {
        if (!version) {
          if (err) {
            return conclude(err);
          }
          if (versions && versions.length > 0) {
            version = versions.pop();
            return verify_version();
          } else {
            return install(pkg, function(err, _version) {
              if (err) {
                return conclude(err);
              }
              version = _version;
              return verify_version();
            });
          }
        } else if (__indexOf.call(versions, version) >= 0) {
          return verify_version();
        } else {
          return install(spec, function(err) {
            if (err) {
              return conclude(err);
            }
            return verify_version();
          });
        }
      });
    };
    _results = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _results.push(read_spec(spec));
    }
    return _results;
  };

  sync = function(specs) {
    var mod, modules, path, pkg, spec, version, versions, _i, _len, _ref, _ref1;
    if (!specs.length) {
      throw new Error('A module name is required');
    }
    modules = [];
    for (_i = 0, _len = specs.length; _i < _len; _i++) {
      spec = specs[_i];
      _ref = spec.split('@'), pkg = _ref[0], version = _ref[1];
      if (mod = ((_ref1 = cache.pkg[pkg]) != null ? _ref1[version || cache.current[pkg]] : void 0) != null) {
        return mod;
      }
      versions = list(pkg);
      if (!version) {
        if (versions && versions.length) {
          version = versions.pop();
        } else {
          version = install(pkg);
        }
      } else if (!(versions && versions.length && __indexOf.call(versions, version) >= 0)) {
        install(spec);
      }
      if (!fs.existsSync(dir + '/' + pkg + '/' + version + '/.dynmod-proper')) {
        throw new Error(util.format(err_msg, spec, spec));
      }
      path = dir + '/' + pkg + '/' + version + '/node_modules/' + pkg;
      modules.push(require(path));
    }
    if (specs.length === 1) {
      return modules[0];
    }
    return modules;
  };

  module.exports = function() {
    var args, callback;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0 || typeof args[args.length - 1] !== 'function') {
      return sync(args);
    }
    callback = args.pop();
    async(args, callback);
    return null;
  };

}).call(this);
